# -*- coding: utf-8 -*-
"""FAR Panel registro datos_v10

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10Dv0dBbgJe3tNTQkXsU1031JCAWOpV_K
"""

#!pip install streamlit pandas pytz
# 1. Importar librer√≠as necesarias
import streamlit as st
import pandas as pd
from datetime import datetime
import os
from zoneinfo import ZoneInfo
import json

DATA_FILE = "usuarios.json"

# Cargar datos de usuarios
if os.path.exists(DATA_FILE):
    try:
        with open(DATA_FILE, "r", encoding="utf-8") as f:
            usuarios = json.load(f)
    except json.JSONDecodeError:
        st.error("‚ùå El archivo de usuarios est√° da√±ado o no tiene formato JSON v√°lido.")
        usuarios = {}
else:
    usuarios = {}

# Estado de sesi√≥n
if "usuario_logueado" not in st.session_state:
    st.session_state.usuario_logueado = None


def guardar_estados():
    if "usuario_logueado" not in st.session_state:
        return  # No hay usuario activo

    usuario = st.session_state.usuario_logueado
    estados = {
        k: v for k, v in st.session_state.items()
        if k.startswith("estado_linea_")
    }

    ruta_archivo = f"estados_{usuario}.json"
    with open(ruta_archivo, "w") as f:
        json.dump(estados, f)


def cargar_estados():
    if "usuario_logueado" not in st.session_state:
        return  # No hay usuario activo

    usuario = st.session_state.usuario_logueado
    ruta_archivo = f"estados_{usuario}.json"
    if os.path.exists(ruta_archivo):
        with open(ruta_archivo, "r") as f:
            estados_guardados = json.load(f)
        for k, v in estados_guardados.items():
            st.session_state[k] = v


# Interfaz de login / registro
st.title("üîê Sistema de producci√≥n")

modo = st.radio("¬øTienes una cuenta?", ["Iniciar sesi√≥n", "Registrarse"])

if modo == "Iniciar sesi√≥n":
    usuario = st.text_input("CEE / Usuario")
    clave = st.text_input("Clave", type="password")

    if st.button("Entrar"):
        if usuario in usuarios and usuarios[usuario]["clave"] == clave:
            st.session_state.usuario_logueado = usuario
            st.success("‚úÖ Sesi√≥n iniciada")
            cargar_estados()  # ‚úÖ Importante
            st.session_state.etapa = "inicio"  # ‚úÖ Esto es lo que hace avanzar
            st.rerun()
        else:
            st.error("‚ùå Usuario o clave incorrecta")

else:  # Registro
    nuevo_usuario = st.text_input("Nuevo CEE / Usuario")
    nueva_clave = st.text_input("Nueva clave", type="password")

    if st.button("Registrarse"):
        if nuevo_usuario in usuarios:
            st.warning("‚ö†Ô∏è Este CEE ya est√° registrado")
        elif nuevo_usuario.strip() == "" or nueva_clave.strip() == "":
            st.warning("‚ö†Ô∏è Completa todos los campos")
        else:
            usuarios[nuevo_usuario] = {"clave": nueva_clave, "lineas": {}}
            with open(DATA_FILE, "w", encoding="utf-8") as f:
                json.dump(usuarios, f, indent=4)
            st.success("‚úÖ Registro exitoso. Ahora inicia sesi√≥n.")
            st.rerun()


if st.session_state.usuario_logueado:
    usuario = st.session_state.usuario_logueado
    st.title(f"üë∑ Bienvenido, {usuario}")

    st.markdown("### ‚ûï A√±adir l√≠nea de producci√≥n")
    nueva_linea = st.text_input("Nombre de la l√≠nea")
    num_estaciones = st.number_input("N√∫mero de estaciones", min_value=1, step=1)
    nombres_estaciones = []
    for i in range(int(num_estaciones)):
        nombre = st.text_input(f"üß± Nombre de la estaci√≥n {i+1}", key=f"estacion_{i+1}")
        nombres_estaciones.append(nombre)

    if st.button("Agregar l√≠nea"):
        if nueva_linea in usuarios[usuario]["lineas"]:
            st.warning("‚ö†Ô∏è Esta l√≠nea ya existe")
        else:
            usuarios[usuario]["lineas"][nueva_linea] = {
            "nombres": nombres_estaciones,
            "num": len(nombres_estaciones)
       }
            with open(DATA_FILE, "w", encoding="utf-8") as f:
                json.dump(usuarios, f, indent=4)
            st.success("‚úÖ L√≠nea agregada correctamente")
            st.rerun()

    # Mostrar l√≠neas existentes
    st.markdown("### üìã L√≠neas registradas")
    for linea, estaciones in usuarios[usuario]["lineas"].items():
        st.write(f"üîπ {linea}: {len(estaciones)} estaciones")
        for idx, nombre_est in enumerate(estaciones, 1):
            st.write(f"   - Estaci√≥n {idx}: {nombre_est}")

    # Luego puedes permitir iniciar el registro de producci√≥n aqu√≠...


# Inicializar variables necesarias para el flujo
if "etapa" not in st.session_state:
    st.session_state.etapa = "inicio" if st.session_state.usuario_logueado else "login"
if "linea" not in st.session_state:
    st.session_state.linea = None
if "estacion" not in st.session_state:
    st.session_state.estacion = None

if "df" not in st.session_state:
    st.session_state.df = pd.DataFrame(columns=[
        "Fecha", "Hora", "CEE", "L√≠nea", "Estaci√≥n", "Estado",
        "Operario", "Turno", "Producto", "Unidades producidas",
        "Unidades defectuosas", "Observaciones"
    ])

if "csv_path" not in st.session_state and st.session_state.usuario_logueado:
    st.session_state.csv_path = f"registro_{st.session_state.usuario_logueado}.csv"



if "usuario_logueado" in st.session_state and st.session_state.usuario_logueado:
    usuario = st.session_state.usuario_logueado
    lineas_usuario = usuarios.get(usuario, {}).get("lineas", {})

    nuevos_estados = False
    for linea, estaciones in lineas_usuario.items():
        if isinstance(estaciones, dict):
            estaciones = estaciones.get("nombres", [])
        for nombre_estacion in estaciones:
            key_estado = f"estado_linea_{linea}_Estacion_{nombre_estacion}"
            if key_estado not in st.session_state:
                st.session_state[key_estado] = "No iniciada"
                nuevos_estados = True
    if nuevos_estados:
        guardar_estados()


def eliminar_registro_por_indice(indice):
    df = st.session_state.df

    if df.empty:
        st.warning("‚ö†Ô∏è No hay registros para eliminar.")
        return

    if indice not in df.index:
        st.error("‚ùå √çndice inv√°lido. No se puede eliminar el registro.")
        return

    # Extraer datos del registro
    registro = df.loc[indice]
    estado_actual = registro["Estado"]
    linea = registro["L√≠nea"]
    estacion = registro["Estaci√≥n"]

    # Validar si el registro es de otra estaci√≥n o l√≠nea (cuando es un cambio de estado)
    if estado_actual in ["Parada producci√≥n", "Reanudaci√≥n producci√≥n"]:
        if (
            linea != st.session_state.linea or
            str(estacion) != str(st.session_state.estacion)
        ):
            st.warning(
                f"‚ö†Ô∏è No se puede eliminar un registro de estado de otra estaci√≥n o l√≠nea.\n\n"
                f"Registro seleccionado: {linea} - Estaci√≥n {estacion}\n"
                f"Est√°s en: {st.session_state.linea} - Estaci√≥n {st.session_state.estacion}"
            )
            return

    # Clave de estado en el nuevo formato
    key_estado = f"estado_linea_{linea}_Estacion_{estacion}"

    # Eliminar el registro
    df = df.drop(indice).reset_index(drop=True)
    st.session_state.df = df

    # Si se elimin√≥ el √∫ltimo registro
    if indice == len(df):  # ya est√° reiniciado con reset_index()
        if estado_actual in ["Parada producci√≥n", "Reanudaci√≥n producci√≥n"]:
            df_filtrado = df[
                (df["L√≠nea"] == linea) &
                (df["Estaci√≥n"] == estacion)
            ]
            if not df_filtrado.empty:
                ultimo_estado = df_filtrado.iloc[-1]["Estado"]
                if ultimo_estado == "Reanudaci√≥n producci√≥n":
                    st.session_state[key_estado] = "En producci√≥n"
                elif ultimo_estado == "Parada producci√≥n":
                    st.session_state[key_estado] = "Parada por incidencia"
                else:
                    st.session_state[key_estado] = "En producci√≥n"
            else:
                st.session_state[key_estado] = "No iniciada"
                st.info("‚ÑπÔ∏è Se ha eliminado el √∫ltimo registro. No quedan registros en esa estaci√≥n.")

            guardar_estados()
            st.session_state.produccion_iniciada = (
                st.session_state[key_estado] == "En producci√≥n"
            )

    st.session_state.df.to_csv(st.session_state.csv_path, index=False, sep=';', encoding='utf-8-sig')
    st.success("‚úÖ Registro eliminado correctamente.")
    st.rerun()


if st.session_state.etapa == "inicio":
    usuario = st.session_state.usuario_logueado
    # Las l√≠neas del usuario
    lineas = list(usuarios[usuario]["lineas"].keys())
    if not lineas:
        st.warning("‚ö†Ô∏è No tienes l√≠neas definidas. Por favor, a√±ade alguna en la secci√≥n anterior.")
    else:
        linea = st.selectbox(f"Selecciona la l√≠nea de {usuario}", lineas, index=0, key="select_linea")
        if st.button("Continuar", key="btn_linea"):
            st.session_state.linea = linea
            st.session_state.etapa = "estacion"
            st.rerun()

elif st.session_state.etapa == "estacion":
    usuario = st.session_state.usuario_logueado
    linea = st.session_state.linea

    # Obtener las estaciones de la l√≠nea:
    # usuarios[usuario]["lineas"][linea] tiene el n√∫mero de estaciones,
    # pero convendr√≠a almacenar tambi√©n los nombres (si a√∫n no, habr√≠a que modificar el registro de l√≠nea para guardar nombres).

    # Suponiendo que guardas nombres en una lista llamada 'nombres_estaciones' dentro del dict l√≠nea
    # Ejemplo: usuarios[usuario]["lineas"][linea] = {"num": 3, "nombres": ["Est1", "Est2", "Est3"]}
    # Si no lo tienes as√≠, tendr√≠as que migrar a ese formato.

    # Aqu√≠ un ejemplo si tienes solo n√∫mero:
    num_estaciones = usuarios[usuario]["lineas"][linea] if isinstance(usuarios[usuario]["lineas"][linea], int) else usuarios[usuario]["lineas"][linea].get("num", 0)

    if isinstance(usuarios[usuario]["lineas"][linea], dict):
        nombres_estaciones = usuarios[usuario]["lineas"][linea].get("nombres", [f"Estaci√≥n {i+1}" for i in range(num_estaciones)])
    else:
        nombres_estaciones = [f"Estaci√≥n {i+1}" for i in range(num_estaciones)]

    estacion_seleccionada = st.selectbox("Selecciona la estaci√≥n", nombres_estaciones, index=0, key="select_estacion")
    if st.button("Continuar", key="btn_estacion"):
        st.session_state.estacion = estacion_seleccionada
        st.session_state.etapa = "registro"
        st.rerun()

elif st.session_state.etapa == "registro":
    usuario = st.session_state.usuario_logueado
    linea = st.session_state.linea
    estacion = st.session_state.estacion

    st.subheader(f"Registro en {usuario} / {linea} / {estacion}")

    key_estado = f"estado_linea_{linea}_Estacion_{estacion}"
    if key_estado not in st.session_state:
        st.session_state[key_estado] = "No iniciada"
        guardar_estados()
    if "produccion_iniciada" not in st.session_state:
        st.session_state.produccion_iniciada = False
    if "mostrar_motivo_reanudacion" not in st.session_state:
        st.session_state.mostrar_motivo_reanudacion = False

    # Mostrar estado actual
    estado = st.session_state[key_estado]

    color = "green"  # Color por defecto
    if estado == "Parada por incidencia":
        color = "red"
    elif estado == "No iniciada":
        color = "gray"
    elif estado == "En producci√≥n":
        color = "green"

    st.markdown(
        f"""
        <div style='font-weight:bold; margin-bottom:8px;'>üõ†Ô∏è Estado actual:
            <span style='background-color:#f0f0f0; color:{color}; padding:4px 8px; border-radius:4px; font-family:monospace;'>
                {estado}
            </span>
        </div>
        """,
        unsafe_allow_html=True
    )

    btn_key_iniciar = f"iniciar_{st.session_state.usuario_logueado}_{st.session_state.linea}_{st.session_state.estacion}"
    iniciar_disabled = estado == "En producci√≥n"

    if st.button("üü¢ Iniciar Producci√≥n", disabled=iniciar_disabled, key=btn_key_iniciar):
        if estado == "Parada por incidencia":
            st.session_state.mostrar_motivo_reanudacion = True
        else:
            zona = ZoneInfo("Europe/Madrid")
            fila_inicio = {
                "Fecha": datetime.now(zona).strftime("%Y-%m-%d"),
                "Hora": datetime.now(zona).strftime("%H:%M:%S"),
                "CEE": st.session_state.usuario_logueado,
                "L√≠nea": st.session_state.linea,
                "Estaci√≥n": st.session_state.estacion,
                "Estado": "Inicio producci√≥n",
                "Operario": "",
                "Turno": "",
                "Producto": "",
                "Unidades producidas": "",
                "Unidades defectuosas": "",
                "Observaciones": "Inicio de la jornada de producci√≥n"
            }
            st.session_state.df = pd.concat([st.session_state.df, pd.DataFrame([fila_inicio])], ignore_index=True)
            st.session_state.df.to_csv(st.session_state.csv_path, index=False, sep=';', encoding='utf-8-sig')

            # Actualizar solo las estaciones del usuario actual
            usuario = st.session_state.usuario_logueado
            for linea, data_linea in usuarios[usuario]["lineas"].items():
                # Si guardas solo n√∫mero
                if isinstance(data_linea, dict):
                    num_estaciones = data_linea.get("num", 0)
                else:
                    num_estaciones = data_linea

                for i in range(1, num_estaciones + 1):
                    key_linea = f"{linea}"
                    key_estado_update = f"estado_linea_{key_linea}_Estacion_Estaci√≥n {i}"
                    st.session_state[key_estado_update] = "En producci√≥n"

            guardar_estados()
            st.session_state.produccion_iniciada = True
            st.success("üü¢ Producci√≥n iniciada correctamente.")
            st.rerun()

    if st.session_state.mostrar_motivo_reanudacion:
        motivo_reanudacion = st.text_area("üìù Motivo de reanudaci√≥n de producci√≥n")

        if st.button("‚úÖ Registrar reanudaci√≥n"):
            if motivo_reanudacion.strip() == "":
                st.warning("‚ö†Ô∏è Por favor, introduce un motivo antes de registrar la reanudaci√≥n.")
            else:
                zona = ZoneInfo("Europe/Madrid")
                fila_reanudacion = {
                    "Fecha": datetime.now(zona).strftime("%Y-%m-%d"),
                    "Hora": datetime.now(zona).strftime("%H:%M:%S"),
                    "CEE": st.session_state.usuario_logueado,
                    "L√≠nea": st.session_state.linea,
                    "Estaci√≥n": st.session_state.estacion,
                    "Estado": "Reanudaci√≥n producci√≥n",
                    "Operario": "",
                    "Turno": "",
                    "Producto": "",
                    "Unidades producidas": "",
                    "Unidades defectuosas": "",
                    "Observaciones": motivo_reanudacion
                }
                st.session_state.df = pd.concat([st.session_state.df, pd.DataFrame([fila_reanudacion])], ignore_index=True)
                st.session_state.df.to_csv(st.session_state.csv_path, index=False, sep=';', encoding='utf-8-sig')

                st.session_state[key_estado] = "En producci√≥n"
                guardar_estados()
                st.session_state.produccion_iniciada = True
                st.session_state.mostrar_motivo_reanudacion = False
                st.success("‚úÖ Producci√≥n reanudada correctamente.")
                st.rerun()



    # Inicializa el estado si no existe a√∫n
    if "mostrar_motivo_parada" not in st.session_state:
        st.session_state.mostrar_motivo_parada = False

    btn_key_parada = f"parada_{st.session_state.usuario_logueado}_{st.session_state.linea}_{st.session_state.estacion}"
    parada_disabled = st.session_state[key_estado] in ["Parada por incidencia", "No iniciada"]

    # Paso 1: Pulsar bot√≥n de parada
    if st.button("‚õî Parada por incidencia", disabled=parada_disabled, key=btn_key_parada):
        st.session_state.mostrar_motivo_parada = True

    # Paso 2: Mostrar cuadro de texto solo si se ha pulsado el bot√≥n
    if st.session_state.mostrar_motivo_parada:
        motivo = st.text_area("üìù Introduce el motivo de la parada")

        if st.button("Registrar parada con motivo"):
            if motivo.strip() == "":
                st.warning("‚ö†Ô∏è Por favor, introduce un motivo antes de registrar la parada.")
            else:
                zona = ZoneInfo("Europe/Madrid")
                fila_parada = {
                    "Fecha": datetime.now(zona).strftime("%Y-%m-%d"),
                    "Hora": datetime.now(zona).strftime("%H:%M:%S"),
                    "CEE": st.session_state.usuario_logueado,
                    "L√≠nea": st.session_state.linea,
                    "Estaci√≥n": st.session_state.estacion,
                    "Estado": "Parada producci√≥n",
                    "Operario": "",
                    "Turno": "",
                    "Producto": "",
                    "Unidades producidas": "",
                    "Unidades defectuosas": "",
                    "Observaciones": motivo
                }
                st.session_state.df = pd.concat([st.session_state.df, pd.DataFrame([fila_parada])], ignore_index=True)
                st.session_state.df.to_csv(st.session_state.csv_path, index=False, sep=';', encoding='utf-8-sig')
                st.session_state[key_estado] = "Parada por incidencia"
                guardar_estados()  # <-- GUARDAR CAMBIOS
                st.session_state.produccion_iniciada = False
                st.success("‚úÖ Parada registrada correctamente.")
                st.session_state.mostrar_motivo_parada = False  # Ocultar cuadro de texto
                st.rerun()


    btn_key_finalizar = f"finalizar_{st.session_state.usuario_logueado}_{st.session_state.linea}_{st.session_state.estacion}"
    finalizar_disabled = st.session_state[key_estado] == "No iniciada"

    if st.button("üèÅ Finalizar jornada", disabled=finalizar_disabled, key=btn_key_finalizar):
        zona = ZoneInfo("Europe/Madrid")
        fila_fin = {
            "Fecha": datetime.now(zona).strftime("%Y-%m-%d"),
            "Hora": datetime.now(zona).strftime("%H:%M:%S"),
            "CEE": st.session_state.usuario_logueado,
            "L√≠nea": st.session_state.linea,
            "Estaci√≥n": st.session_state.estacion,
            "Estado": "Fin producci√≥n",
            "Operario": "",
            "Turno": "",
            "Producto": "",
            "Unidades producidas": "",
            "Unidades defectuosas": "",
            "Observaciones": "Fin de la jornada de producci√≥n"
        }
        st.session_state.df = pd.concat([st.session_state.df, pd.DataFrame([fila_fin])], ignore_index=True)
        st.session_state.df.to_csv(st.session_state.csv_path, index=False, sep=';', encoding='utf-8-sig')
        # Aqu√≠ podr√≠as actualizar estados o variables si es necesario
        st.success("üèÅ Jornada finalizada correctamente.")
        st.rerun()

        # Establecer "No iniciada" en todas las estaciones al finalizar jornada
        for cee in cees:
            for linea in lineas_por_cee[cee]:
                key_linea = f"{cee}-{linea}"
                num_estaciones = estaciones_por_linea[key_linea]
                for i in range(1, num_estaciones + 1):
                    key_estado = f"estado_linea_{key_linea}_Estacion_{i}"
                    st.session_state[key_estado] = "No iniciada"
        guardar_estados()  # <-- GUARDAR CAMBIOS
        st.session_state.mostrar_motivo_parada = False  # Asegura que no se muestre texto de parada
        st.success("‚úÖ Jornada finalizada correctamente.")
        st.rerun()

    # Si la producci√≥n est√° iniciada, mostrar formulario
    if st.session_state[key_estado] == "En producci√≥n":
        st.markdown("### üßæ Registrar producci√≥n")
        operario = st.text_input("üë§ Operario")
        turno = st.radio("üïí Turno", ["Ma√±ana", "Tarde", "Noche"])
        producto = st.selectbox("üß± Producto", ["Producto A", "Producto B", "Producto C"])
        unidades_producidas = st.number_input("üî¢ Unidades producidas", min_value=1, step=1)
        unidades_defectuosas = st.number_input("‚ùå Unidades defectuosas", min_value=0, step=1)
        observaciones = st.text_area("üìù Observaciones")

        if st.button("‚úÖ Registrar producci√≥n"):
            zona = ZoneInfo("Europe/Madrid")
            nueva_fila = {
                "Fecha": datetime.now(zona).strftime("%Y-%m-%d"),
                "Hora": datetime.now(zona).strftime("%H:%M:%S"),
                "CEE": st.session_state.usuario_logueado,  # <-- Cambio aqu√≠
                "L√≠nea": st.session_state.linea,
                "Estaci√≥n": st.session_state.estacion,
                "Estado": st.session_state[key_estado],
                "Operario": operario,
                "Turno": turno,
                "Producto": producto,
                "Unidades producidas": unidades_producidas,
                "Unidades defectuosas": unidades_defectuosas,
                "Observaciones": observaciones
            }
            st.session_state.df = pd.concat([st.session_state.df, pd.DataFrame([nueva_fila])], ignore_index=True)
            st.session_state.df.to_csv(st.session_state.csv_path, index=False, sep=';', encoding='utf-8-sig')
            st.success("‚úÖ Registro guardado correctamente.")
    else:
        st.warning("‚ö†Ô∏è Debes iniciar la producci√≥n antes de poder registrar unidades.")

    # Mostrar √∫ltimos registros
    st.markdown("---")
    st.markdown("### üìã √öltimos registros")
    st.dataframe(st.session_state.df.tail(5), use_container_width=True)



# --- BOTONES DE NAVEGACI√ìN Y EDICI√ìN SEG√öN LA ETAPA ---

if st.session_state.etapa == "linea":
    st.markdown("---")
    if st.button("üîô Volver al inicio"):
        st.session_state.etapa = "CEE"
        # Limpia variables que dependen de la selecci√≥n previa
        st.session_state.pop("csv_path", None)
        st.session_state.pop("usuario_logueado", None)  # <-- cambio aqu√≠
        st.session_state.pop("linea", None)
        st.session_state.pop("estacion", None)
        st.session_state.pop("df", None)
        st.session_state.pop("produccion_iniciada", None)
        st.rerun()  # <--- A√±adido

elif st.session_state.etapa == "estacion":
    st.markdown("---")
    col1, col2 = st.columns(2)
    with col1:
        if st.button("üîÅ Cambiar l√≠nea"):
            st.session_state.etapa = "linea"
            st.rerun()
    with col2:
        if st.button("üîô Volver al inicio"):
            st.session_state.etapa = "CEE"
            # Limpia variables que dependen de la selecci√≥n previa
            st.session_state.pop("csv_path", None)
            st.session_state.pop("usuario_logueado", None)  # <-- cambio aqu√≠
            st.session_state.pop("linea", None)
            st.session_state.pop("estacion", None)
            st.session_state.pop("df", None)
            st.session_state.pop("produccion_iniciada", None)
            st.rerun()  # <--- A√±adido

elif st.session_state.etapa == "registro":
    # Descargar CSV
    if "csv_path" in st.session_state and os.path.exists(st.session_state.csv_path):
        with open(st.session_state.csv_path, "rb") as f:
            st.download_button(
                "‚¨áÔ∏è Descargar CSV",
                f,
                file_name=f"registro_produccion_{st.session_state.usuario_logueado}.csv",  # <-- cambio aqu√≠
                mime="text/csv"
            )

    # --- Bot√≥n para mostrar/ocultar edici√≥n de registros ---
    if "mostrar_edicion" not in st.session_state:
        st.session_state.mostrar_edicion = False

    if st.button("‚úèÔ∏è Modificar o eliminar un registro"):
        # Verifica si hay registros
        if st.session_state.df.empty:
            st.warning("‚ö†Ô∏è A√∫n no hay registros disponibles para modificar o eliminar.")
            st.session_state.mostrar_edicion = False
        else:
            st.session_state.mostrar_edicion = not st.session_state.mostrar_edicion

    if st.session_state.mostrar_edicion:
        st.markdown("### ‚úèÔ∏è Selecciona un registro reciente")

        ultimos_registros = st.session_state.df.tail(5).reset_index(drop=True)

        def formatear_registro(row):
            # Aqu√≠ puedes dejar el campo 'CEE' para mostrar el usuario/logueado/CEE actual
            return f"{row['Fecha']} - {row['Hora']} - {row['CEE']} - {row['L√≠nea']} - {row['Estaci√≥n']} - {row['Estado']} - {row['Operario']} - {row['Turno']} - {row['Producto']} - {row['Unidades producidas']} - {row['Unidades defectuosas']} - {row['Observaciones']}"

        opciones = [(i, formatear_registro(row)) for i, row in ultimos_registros.iterrows()]
        opciones_dict = {desc: idx for idx, desc in opciones}

        registro_str = st.selectbox("Selecciona un registro", list(opciones_dict.keys()), key="registro_selectbox")
        registro_seleccionado = opciones_dict[registro_str]
        registro = ultimos_registros.loc[registro_seleccionado]

        clave_registro = f"registro_{registro_seleccionado}"

        if registro["Estado"] not in ["Reanudaci√≥n producci√≥n", "Parada producci√≥n"]:
            nuevo_operario = st.text_input("üë§ Operario", value=registro["Operario"], key=f"operario_{clave_registro}")
            turnos_validos = ["Ma√±ana", "Tarde", "Noche"]
            turno_actual = registro.get("Turno", "")
            if turno_actual in turnos_validos:
                nuevo_turno = st.radio("üïí Turno", turnos_validos, index=turnos_validos.index(turno_actual), key=f"turno_{clave_registro}")
            else:
                nuevo_turno = st.radio("üïí Turno", turnos_validos, key=f"turno_{clave_registro}")

            productos_disponibles = ["Producto A", "Producto B", "Producto C"]
            producto_actual = registro.get("Producto", "")

            if producto_actual in productos_disponibles:
                index_producto = productos_disponibles.index(producto_actual)
            else:
                index_producto = 0

            nuevo_producto = st.selectbox("üß± Producto", productos_disponibles, index=index_producto, key=f"producto_{clave_registro}")

            try:
                valor_producidas = int(registro.get("Unidades producidas", 0))
            except (ValueError, TypeError):
                valor_producidas = 0

            nuevas_producidas = st.number_input("üî¢ Unidades producidas", min_value=0, value=valor_producidas, step=1)

            try:
                valor_defectuosas = int(registro.get("Unidades defectuosas", 0))
            except (ValueError, TypeError):
                valor_defectuosas = 0

            nuevas_defectuosas = st.number_input("‚ùå Unidades defectuosas", min_value=0, value=valor_defectuosas, step=1, key=f"defectuosas_{clave_registro}")
            nuevas_observaciones = st.text_area("üìù Observaciones", value=registro["Observaciones"], key=f"observaciones_{clave_registro}")

            if st.button("üíæ Guardar cambios en el registro seleccionado", key=f"guardar_{clave_registro}"):
                index_original = st.session_state.df.tail(5).index[registro_seleccionado]
                st.session_state.df.at[index_original, "Operario"] = nuevo_operario
                st.session_state.df.at[index_original, "Turno"] = nuevo_turno
                st.session_state.df.at[index_original, "Producto"] = nuevo_producto
                st.session_state.df.at[index_original, "Unidades producidas"] = nuevas_producidas
                st.session_state.df.at[index_original, "Unidades defectuosas"] = nuevas_defectuosas
                st.session_state.df.at[index_original, "Observaciones"] = nuevas_observaciones
                st.session_state.df.to_csv(st.session_state.csv_path, index=False, sep=';', encoding='utf-8-sig')
                st.success("‚úÖ Registro modificado correctamente.")
                st.rerun()
        else:
            st.info("üõ† Este registro es de inicio o parada de producci√≥n, solo puede eliminarse.")

        if st.button("üóëÔ∏è Eliminar registro seleccionado", key=f"eliminar_{clave_registro}"):
            index_original = st.session_state.df.tail(5).index[registro_seleccionado]
            eliminar_registro_por_indice(index_original)


    # Eliminar archivo
    if st.button("üóëÔ∏è Eliminar archivo de producci√≥n"):
        if os.path.exists(st.session_state.csv_path):
            os.remove(st.session_state.csv_path)
            st.warning(f"Archivo `{st.session_state.csv_path}` eliminado. Recarga la app para reiniciar.")
        else:
            st.warning("‚ö†Ô∏è No se encontr√≥ el archivo para eliminar.")

    # --- Botones de navegaci√≥n al final ---
    st.markdown("---")
    col1, col2, col3 = st.columns(3)

    with col1:
        if st.button("üîÅ Cambiar estaci√≥n"):
            st.session_state.etapa = "estacion"
            st.rerun()

    with col2:
        if st.button("üîÅ Cambiar l√≠nea"):
            st.session_state.etapa = "linea"
            st.rerun()

    with col3:
        if st.button("üîô Volver al inicio"):
            st.session_state.etapa = "CEE"
            # Limpia variables que dependen de la selecci√≥n previa
            st.session_state.pop("csv_path", None)
            st.session_state.pop("usuario_logueado", None)  # <-- Cambiado de 'cee'
            st.session_state.pop("linea", None)
            st.session_state.pop("estacion", None)
            st.session_state.pop("df", None)
            st.session_state.pop("produccion_iniciada", None)
            st.rerun()  # <--- A√±adido