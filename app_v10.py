# -*- coding: utf-8 -*-
"""FAR Panel registro datos_v10

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10Dv0dBbgJe3tNTQkXsU1031JCAWOpV_K
"""

#!pip install streamlit pandas pytz
# 1. Importar librer√≠as necesarias
import streamlit as st
import pandas as pd
from datetime import datetime
import os
from zoneinfo import ZoneInfo
import json

DATA_FILE = "usuarios.json"

# Cargar datos de usuarios
if os.path.exists(DATA_FILE):
    try:
        with open(DATA_FILE, "r", encoding="utf-8") as f:
            usuarios = json.load(f)
    except json.JSONDecodeError:
        st.error("‚ùå El archivo de usuarios est√° da√±ado o no tiene formato JSON v√°lido.")
        usuarios = {}
else:
    usuarios = {}

# Estado de sesi√≥n
if "usuario_logueado" not in st.session_state:
    st.session_state.usuario_logueado = None


def guardar_estados():
    if "usuario_logueado" not in st.session_state:
        return  # No hay usuario activo

    usuario = st.session_state.usuario_logueado
    estados = {
        k: v for k, v in st.session_state.items()
        if k.startswith("estado_linea_") or k.startswith("linea_parada_general_")
    }

    ruta_archivo = f"estados_{usuario}.json"
    with open(ruta_archivo, "w") as f:
        json.dump(estados, f)


def cargar_estados():
    if "usuario_logueado" not in st.session_state:
        return  # No hay usuario activo

    usuario = st.session_state.usuario_logueado
    ruta_archivo = f"estados_{usuario}.json"
    if os.path.exists(ruta_archivo):
        with open(ruta_archivo, "r") as f:
            estados_guardados = json.load(f)
        for k, v in estados_guardados.items():
            st.session_state[k] = v

def safe_rerun():
    st.experimental_rerun()

if (
    "usuario_logueado" not in st.session_state or not st.session_state.usuario_logueado
) and st.session_state.get("etapa") != "recuperar_clave":
    st.title("üì¶ Registro de Producci√≥n - Centro Especial de Empleo")

    # Modo inicial normal (no forzado aqu√≠)
    modo = st.radio("¬øTienes una cuenta?", ["Iniciar sesi√≥n", "Registrarse"], key="modo")

    # Si el registro acaba de completarse, muestra aviso sin forzar rerun ni cambiar modo
    if st.session_state.get("registro_completado"):
        st.success("‚úÖ Registro exitoso. Por favor, refresca la p√°gina para iniciar sesi√≥n con tu nuevo usuario.")
        # No borramos el flag todav√≠a, lo borramos solo despu√©s de refrescar manual

    if modo == "Iniciar sesi√≥n":
        usuario = st.text_input("CEE / Usuario")
        clave = st.text_input("Clave", type="password")

        if st.button("Entrar"):
            if usuario in usuarios and usuarios[usuario]["clave"] == clave:
                st.session_state.usuario_logueado = usuario
                st.success("‚úÖ Sesi√≥n iniciada")
                cargar_estados()
                st.session_state.etapa = "inicio_usuario"
                st.rerun()
            else:
                st.error("‚ùå Usuario o clave incorrecta")

        if st.button("¬øHas olvidado tu clave?"):
            st.session_state.etapa = "recuperar_clave"
            st.rerun()

    else:  # Registro
        nuevo_usuario = st.text_input("Nuevo CEE / Usuario")
        nueva_clave = st.text_input("Nueva clave", type="password")
        confirmar_clave = st.text_input("Confirmar clave", type="password")
        pregunta_seguridad = st.text_input("üîê Pregunta de seguridad (ej. ¬øTu comida favorita?)")
        respuesta_seguridad = st.text_input("üîë Respuesta a la pregunta de seguridad", type="password")

        st.markdown("### ‚ûï A√±adir l√≠nea(s) de producci√≥n")

        lineas_registro = {}
        num_lineas = st.number_input("N√∫mero de l√≠neas a registrar", min_value=1, step=1, key="num_lineas_registro")

        for i in range(int(num_lineas)):
            nombre_linea = st.text_input(f"üè≠ Nombre de la l√≠nea {i+1}", key=f"nombre_linea_{i}")
            num_estaciones = st.number_input(f"N√∫mero de estaciones para l√≠nea {i+1}", min_value=1, step=1, key=f"num_estaciones_{i}")

            estaciones = []
            for j in range(int(num_estaciones)):
                nombre_estacion = st.text_input(f"üß∞ Nombre estaci√≥n {j+1} de l√≠nea {i+1}", key=f"estacion_{i}_{j}")
                estaciones.append(nombre_estacion)

            lineas_registro[nombre_linea] = {
                "num": num_estaciones,
                "nombres": estaciones
            }

        st.markdown("### üì¶ Productos a fabricar")

        productos = []
        num_productos = st.number_input("N√∫mero de productos diferentes", min_value=1, step=1, key="num_productos_registro")

        for p in range(int(num_productos)):
            nombre_producto = st.text_input(f"üè∑Ô∏è Nombre del producto {p+1}", key=f"nombre_producto_{p}")
            productos.append(nombre_producto)

        if st.button("Registrarse"):
            if nuevo_usuario in usuarios:
                st.warning("‚ö†Ô∏è Este CEE ya est√° registrado")
            elif nuevo_usuario.strip() == "" or nueva_clave.strip() == "":
                st.warning("‚ö†Ô∏è Completa todos los campos de usuario y clave")
            elif nueva_clave != confirmar_clave:
                st.warning("‚ùå Las claves no coinciden. Vuelve a escribirlas.")
            elif any(nombre.strip() == "" for nombre in lineas_registro.keys()):
                st.warning("‚ö†Ô∏è Todos los nombres de l√≠nea deben estar completos")
            else:
                usuarios[nuevo_usuario] = {
                    "clave": nueva_clave,
                    "lineas": lineas_registro,
                    "productos": productos,
                    "pregunta": pregunta_seguridad,
                    "respuesta": respuesta_seguridad.strip().lower()
                }
                with open(DATA_FILE, "w", encoding="utf-8") as f:
                    json.dump(usuarios, f, indent=4)

                st.session_state["registro_completado"] = True
                st.success("‚úÖ Registro exitoso. Por favor, refresca la p√°gina para iniciar sesi√≥n.")

# Limpieza del flag registro_completado solo cuando ya no se muestra el mensaje
# (Opcional: puedes borrarlo si el usuario ya cambi√≥ a modo iniciar sesi√≥n o similar)
if st.session_state.get("registro_completado") and st.session_state.get("modo") == "Iniciar sesi√≥n":
    del st.session_state["registro_completado"]


# Inicializar variables necesarias para el flujo
if "etapa" not in st.session_state:
    st.session_state.etapa = "inicio" if st.session_state.usuario_logueado else "login"
if "linea" not in st.session_state:
    st.session_state.linea = None
if "estacion" not in st.session_state:
    st.session_state.estacion = None

if "df" not in st.session_state:
    st.session_state.df = pd.DataFrame(columns=[
        "Fecha", "Hora", "CEE", "L√≠nea", "Estaci√≥n", "Estado",
        "Operario", "Turno", "Producto", "Unidades producidas",
        "Unidades defectuosas", "Observaciones"
    ])

if "csv_path" not in st.session_state and st.session_state.usuario_logueado:
    st.session_state.csv_path = f"registro_{st.session_state.usuario_logueado}.csv"



if "usuario_logueado" in st.session_state and st.session_state.usuario_logueado:
    usuario = st.session_state.usuario_logueado
    lineas_usuario = usuarios.get(usuario, {}).get("lineas", {})

    nuevos_estados = False
    for linea, estaciones in lineas_usuario.items():
        if isinstance(estaciones, dict):
            estaciones = estaciones.get("nombres", [])
        for nombre_estacion in estaciones:
            key_estado = f"estado_linea_{linea}_Estacion_{nombre_estacion}"
            if key_estado not in st.session_state:
                st.session_state[key_estado] = "No iniciada"
                nuevos_estados = True
    if nuevos_estados:
        guardar_estados()


def eliminar_registro_por_indice(indice):
    df = st.session_state.df

    if df.empty:
        st.warning("‚ö†Ô∏è No hay registros para eliminar.")
        return

    if indice not in df.index:
        st.error("‚ùå √çndice inv√°lido. No se puede eliminar el registro.")
        return

    # Extraer datos del registro
    registro = df.loc[indice]
    estado_actual = registro["Estado"]
    linea = registro["L√≠nea"]
    estacion = registro["Estaci√≥n"]

    # Validar si el registro es de otra estaci√≥n o l√≠nea (cuando es un cambio de estado)
    if estado_actual in ["Parada producci√≥n", "Reanudaci√≥n producci√≥n"]:
        if (
            linea != st.session_state.linea or
            str(estacion) != str(st.session_state.estacion)
        ):
            st.warning(
                f"‚ö†Ô∏è No se puede eliminar un registro de estado de otra estaci√≥n o l√≠nea.\n\n"
                f"Registro seleccionado: {linea} - Estaci√≥n {estacion}\n"
                f"Est√°s en: {st.session_state.linea} - Estaci√≥n {st.session_state.estacion}"
            )
            return

    # Clave de estado en el nuevo formato
    key_estado = f"estado_linea_{linea}_Estacion_{estacion}"

    # Eliminar el registro
    df = df.drop(indice).reset_index(drop=True)
    st.session_state.df = df

    # Si se elimin√≥ el √∫ltimo registro
    if indice == len(df):  # ya est√° reiniciado con reset_index()
        if estado_actual in ["Parada producci√≥n", "Reanudaci√≥n producci√≥n"]:
            df_filtrado = df[
                (df["L√≠nea"] == linea) &
                (df["Estaci√≥n"] == estacion)
            ]
            if not df_filtrado.empty:
                ultimo_estado = df_filtrado.iloc[-1]["Estado"]
                if ultimo_estado == "Reanudaci√≥n producci√≥n":
                    st.session_state[key_estado] = "En producci√≥n"
                elif ultimo_estado == "Parada producci√≥n":
                    st.session_state[key_estado] = "Parada por incidencia"
                else:
                    st.session_state[key_estado] = "En producci√≥n"
            else:
                st.session_state[key_estado] = "No iniciada"
                st.info("‚ÑπÔ∏è Se ha eliminado el √∫ltimo registro. No quedan registros en esa estaci√≥n.")

            guardar_estados()
            st.session_state.produccion_iniciada = (
                st.session_state[key_estado] == "En producci√≥n"
            )

    st.session_state.df.to_csv(st.session_state.csv_path, index=False, sep=';', encoding='utf-8-sig')
    st.success("‚úÖ Registro eliminado correctamente.")
    st.rerun()


if st.session_state.etapa == "inicio_usuario":

    st.title(f"üì¶ Registro de Producci√≥n - {st.session_state.usuario_logueado}")

    st.write("Selecciona una opci√≥n:")

    col1, col2 = st.columns(2)
    with col1:
        if st.button("üìä Ir a producci√≥n"):
            # Flujo actual que lleva a selecci√≥n de l√≠nea
            st.session_state.etapa = "linea"
            st.rerun()
    with col2:
        if st.button("‚öôÔ∏è Configuraci√≥n de usuario"):
            st.session_state.etapa = "configurar"
            st.rerun()


elif st.session_state.etapa == "recuperar_clave":
    st.title("üîê Recuperar clave de acceso")

    if "subetapa_recuperar" not in st.session_state:
        st.session_state.subetapa_recuperar = "introducir_usuario"

    if st.session_state.subetapa_recuperar == "introducir_usuario":
        usuario_recuperar = st.text_input("üë§ Introduce tu nombre de usuario (CEE)", key="usuario_recuperar_input")

        if st.button("Continuar"):
            if usuario_recuperar in usuarios:
                st.session_state.usuario_para_recuperar = usuario_recuperar
                st.session_state.subetapa_recuperar = "introducir_respuesta"
                st.rerun()
            else:
                st.warning("‚ö†Ô∏è Usuario no encontrado.")

    elif st.session_state.subetapa_recuperar == "introducir_respuesta":
        usuario_recuperar = st.session_state.usuario_para_recuperar
        pregunta = usuarios[usuario_recuperar].get("pregunta", None)

        if pregunta:
            st.info(f"‚ùì Pregunta de seguridad: {pregunta}")
            respuesta_introducida = st.text_input("‚úèÔ∏è Tu respuesta", type="password", key="respuesta_recuperar")

            if st.button("üì¨ Recuperar clave"):
                if respuesta_introducida.strip().lower() == usuarios[usuario_recuperar].get("respuesta", "").lower():
                    st.success(f"‚úÖ Tu clave es: **{usuarios[usuario_recuperar]['clave']}**")
                else:
                    st.error("‚ùå Respuesta incorrecta. Intenta de nuevo.")
        else:
            st.warning("‚ö†Ô∏è Este usuario no tiene configurada una pregunta de seguridad.")
            st.session_state.subetapa_recuperar = "introducir_usuario"

    if st.button("üîô Volver al inicio"):
        st.session_state.etapa = "inicio"
        st.session_state.subetapa_recuperar = "introducir_usuario"
        st.rerun()


elif st.session_state.etapa == "configurar":
    st.title(f"‚öôÔ∏è Configuraci√≥n - {st.session_state.usuario_logueado}")

    usuario = st.session_state.usuario_logueado
    datos = usuarios[usuario]["lineas"]

    st.subheader("üîë Cambiar clave")
    nueva_clave = st.text_input("Nueva clave", type="password", key="nueva_clave")
    confirmar_clave = st.text_input("Confirmar nueva clave", type="password", key="confirmar_clave")

    st.markdown("---")

    # Nuevo n√∫mero total de l√≠neas
    num_lineas_nuevas = st.number_input(
        "N√∫mero total de l√≠neas de producci√≥n",
        min_value=1,
        step=1,
        value=len(datos),
        key="config_num_lineas"
    )

    nuevas_lineas = {}

    for i in range(int(num_lineas_nuevas)):
        st.subheader(f"‚úèÔ∏è L√≠nea {i+1}")

        nombre_linea_key = f"config_nombre_linea_{i}"
        nombre_linea = st.text_input(f"Nombre de la l√≠nea {i+1}", key=nombre_linea_key)

        num_estaciones = st.number_input(
            f"N√∫mero de estaciones para l√≠nea {i+1}",
            min_value=1,
            step=1,
            value=datos[list(datos.keys())[i]]["num"] if i < len(datos) else 1,
            key=f"config_num_estaciones_{i}"
        )

        estaciones = []
        for j in range(int(num_estaciones)):
            est_key = f"config_estacion_{i}_{j}"
            nombre_est = datos[list(datos.keys())[i]]["nombres"][j] if (i < len(datos) and j < len(datos[list(datos.keys())[i]]["nombres"])) else ""
            estaciones.append(st.text_input(f"Nombre estaci√≥n {j+1} de l√≠nea {i+1}", value=nombre_est, key=est_key))

        nuevas_lineas[nombre_linea] = {
            "num": num_estaciones,
            "nombres": estaciones
        }

    if st.button("üíæ Guardar cambios", key="boton_guardar_config"):
        usuarios[usuario]["lineas"] = nuevas_lineas

        if nueva_clave.strip() != "":
            if nueva_clave == confirmar_clave:
                usuarios[usuario]["clave"] = nueva_clave
            else:
                st.error("‚ùå Las claves no coinciden. No se actualiz√≥ la contrase√±a.")
                st.stop()

        with open(DATA_FILE, "w", encoding="utf-8") as f:
            json.dump(usuarios, f, indent=4)

        st.success("‚úÖ Cambios guardados correctamente")
        st.session_state.etapa = "linea"
        st.rerun()

    if st.button("‚¨ÖÔ∏è Volver"):
        st.session_state.etapa = "inicio_usuario"
        st.rerun()



elif st.session_state.etapa == "linea":
    usuario = st.session_state.usuario_logueado
    lineas = list(usuarios[usuario]["lineas"].keys())
    st.title(f"üì¶ Registro de Producci√≥n - {st.session_state.usuario_logueado}")
    if not lineas:
      st.warning("‚ö†Ô∏è No tienes l√≠neas definidas. Por favor, a√±ade alguna en la secci√≥n anterior.")
    else:
        linea = st.selectbox(f"Selecciona la l√≠nea de {usuario}", lineas, index=0, key="select_linea")
        if st.button("Continuar", key="btn_linea"):
            st.session_state.linea = linea
            st.session_state.etapa = "estacion"
            st.rerun()


elif st.session_state.etapa == "estacion":
    usuario = st.session_state.usuario_logueado
    linea = st.session_state.linea
    st.title(f"üì¶ Registro de Producci√≥n - {st.session_state.usuario_logueado}")

    # Obtener las estaciones de la l√≠nea:
    # usuarios[usuario]["lineas"][linea] tiene el n√∫mero de estaciones,
    # pero convendr√≠a almacenar tambi√©n los nombres (si a√∫n no, habr√≠a que modificar el registro de l√≠nea para guardar nombres).

    # Suponiendo que guardas nombres en una lista llamada 'nombres_estaciones' dentro del dict l√≠nea
    # Ejemplo: usuarios[usuario]["lineas"][linea] = {"num": 3, "nombres": ["Est1", "Est2", "Est3"]}
    # Si no lo tienes as√≠, tendr√≠as que migrar a ese formato.

    # Aqu√≠ un ejemplo si tienes solo n√∫mero:
    num_estaciones = usuarios[usuario]["lineas"][linea] if isinstance(usuarios[usuario]["lineas"][linea], int) else usuarios[usuario]["lineas"][linea].get("num", 0)

    if isinstance(usuarios[usuario]["lineas"][linea], dict):
        nombres_estaciones = usuarios[usuario]["lineas"][linea].get("nombres", [f"Estaci√≥n {i+1}" for i in range(num_estaciones)])
    else:
        nombres_estaciones = [f"Estaci√≥n {i+1}" for i in range(num_estaciones)]

    estacion_seleccionada = st.selectbox("Selecciona la estaci√≥n", nombres_estaciones, index=0, key="select_estacion")
    if st.button("Continuar", key="btn_estacion"):
        st.session_state.estacion = estacion_seleccionada
        st.session_state.etapa = "registro"
        st.rerun()

elif st.session_state.etapa == "registro":
    usuario = st.session_state.usuario_logueado
    linea = st.session_state.linea
    estacion = st.session_state.estacion
    st.title(f"üì¶ Registro de Producci√≥n - {st.session_state.usuario_logueado}")

    st.subheader(f"Registro en {usuario} / linea {linea} / estaci√≥n {estacion}")

    key_estado = f"estado_linea_{linea}_Estacion_{estacion}"
    if key_estado not in st.session_state:
        st.session_state[key_estado] = "No iniciada"
        guardar_estados()
    if "produccion_iniciada" not in st.session_state:
        st.session_state.produccion_iniciada = False
    if "mostrar_motivo_reanudacion" not in st.session_state:
        st.session_state.mostrar_motivo_reanudacion = False

    # Mostrar estado actual
    estado = st.session_state.get(key_estado, "No iniciada")

    color = "green"  # Color por defecto
    if estado == "Parada por incidencia":
        color = "red"
    elif estado == "No iniciada":
        color = "gray"
    elif estado == "En producci√≥n":
        color = "green"

    st.markdown(
        f"""
        <div style='font-weight:bold; margin-bottom:8px;'>üõ†Ô∏è Estado actual:
            <span style='background-color:#f0f0f0; color:{color}; padding:4px 8px; border-radius:4px; font-family:monospace;'>
                {estado}
            </span>
        </div>
        """,
        unsafe_allow_html=True
    )

    btn_key_iniciar = f"iniciar_{st.session_state.usuario_logueado}_{st.session_state.linea}_{st.session_state.estacion}"
    iniciar_disabled = estado == "En producci√≥n"

    clave_linea_parada = f"parada_general_linea_{st.session_state.linea}"
    if clave_linea_parada not in st.session_state:
        st.session_state[clave_linea_parada] = False

    if st.button("üü¢ Iniciar Producci√≥n", disabled=iniciar_disabled, key=btn_key_iniciar):
        if estado == "Parada por incidencia":
            st.session_state.mostrar_motivo_reanudacion = True
        else:
            zona = ZoneInfo("Europe/Madrid")
            fila_inicio = {
                "Fecha": datetime.now(zona).strftime("%Y-%m-%d"),
                "Hora": datetime.now(zona).strftime("%H:%M:%S"),
                "CEE": usuario,
                "L√≠nea": linea,
                "Estaci√≥n": estacion,
                "Estado": "Inicio producci√≥n",
                "Operario": "",
                "Turno": "",
                "Producto": "",
                "Unidades producidas": "",
                "Unidades defectuosas": "",
                "Observaciones": "Inicio de la jornada de producci√≥n"
            }
            st.session_state.df = pd.concat([st.session_state.df, pd.DataFrame([fila_inicio])], ignore_index=True)
            st.session_state.df.to_csv(st.session_state.csv_path, index=False, sep=';', encoding='utf-8-sig')

            for linea_actual, data_linea in usuarios[usuario]["lineas"].items():
                nombres_estaciones = data_linea.get("nombres", [])
                for nombre_estacion in nombres_estaciones:
                    key_estado_update = f"estado_linea_{linea_actual}_Estacion_{nombre_estacion}"
                    st.session_state[key_estado_update] = "En producci√≥n"

            guardar_estados()
            st.session_state.produccion_iniciada = True

            # üîÑ Re-ejecutar para actualizar el valor de `estado` en pantalla
            st.rerun()


    if st.session_state.mostrar_motivo_reanudacion:
        motivo_reanudacion = st.text_area("üìù Motivo de reanudaci√≥n de producci√≥n")

        if st.button("‚úÖ Registrar reanudaci√≥n"):
            if motivo_reanudacion.strip() == "":
                st.warning("‚ö†Ô∏è Por favor, introduce un motivo antes de registrar la reanudaci√≥n.")
            else:
                if st.session_state.get(clave_linea_parada, False):
                    zona = ZoneInfo("Europe/Madrid")
                    fila_reanudacion = {
                    "Fecha": datetime.now(zona).strftime("%Y-%m-%d"),
                    "Hora": datetime.now(zona).strftime("%H:%M:%S"),
                    "CEE": st.session_state.usuario_logueado,
                    "L√≠nea": st.session_state.linea,
                    "Estaci√≥n": "",  # Estaci√≥n vac√≠a para indicar toda la l√≠nea
                    "Estado": "Reanudaci√≥n producci√≥n",
                    "Operario": "",
                    "Turno": "",
                    "Producto": "",
                    "Unidades producidas": "",
                    "Unidades defectuosas": "",
                    "Observaciones": motivo_reanudacion
                }

                    nombres_estaciones = usuarios[st.session_state.usuario_logueado]["lineas"][st.session_state.linea]["nombres"]

                    for nombre_estacion in nombres_estaciones:
                        key_estado_update = f"estado_linea_{st.session_state.linea}_Estacion_{nombre_estacion}"
                        st.session_state[key_estado_update] = "En producci√≥n"
                    st.session_state[clave_linea_parada] = False  # Resetear bandera


                else:
                    zona = ZoneInfo("Europe/Madrid")
                    fila_reanudacion = {
                        "Fecha": datetime.now(zona).strftime("%Y-%m-%d"),
                        "Hora": datetime.now(zona).strftime("%H:%M:%S"),
                        "CEE": st.session_state.usuario_logueado,
                        "L√≠nea": st.session_state.linea,
                        "Estaci√≥n": st.session_state.estacion,
                        "Estado": "Reanudaci√≥n producci√≥n",
                        "Operario": "",
                        "Turno": "",
                        "Producto": "",
                        "Unidades producidas": "",
                        "Unidades defectuosas": "",
                        "Observaciones": motivo_reanudacion
                    }
                    st.session_state[key_estado] = "En producci√≥n"

                st.session_state.df = pd.concat([st.session_state.df, pd.DataFrame([fila_reanudacion])], ignore_index=True)
                st.session_state.df.to_csv(st.session_state.csv_path, index=False, sep=';', encoding='utf-8-sig')

                guardar_estados()
                st.session_state.produccion_iniciada = True
                st.session_state.mostrar_motivo_reanudacion = False
                st.success("‚úÖ Producci√≥n reanudada correctamente.")
                st.rerun()



    # Inicializa el estado si no existe a√∫n
    if "mostrar_motivo_parada" not in st.session_state:
        st.session_state.mostrar_motivo_parada = False

    btn_key_parada = f"parada_{st.session_state.usuario_logueado}_{st.session_state.linea}_{st.session_state.estacion}"
    parada_disabled = st.session_state[key_estado] in ["Parada por incidencia", "No iniciada"]

    # Paso 1: Pulsar bot√≥n de parada
    if st.button("‚õî Parada por incidencia", disabled=parada_disabled, key=btn_key_parada):
        st.session_state.mostrar_motivo_parada = True

    # Paso 2: Mostrar cuadro de texto solo si se ha pulsado el bot√≥n
    if st.session_state.mostrar_motivo_parada:
        opcion_impacto = st.radio("¬øLa parada afecta a:", ["Estaci√≥n", "L√≠nea"], key="opcion_impacto")
        motivo = st.text_area("üìù Introduce el motivo de la parada")

        if st.button("Registrar parada con motivo"):
            if motivo.strip() == "":
                st.warning("‚ö†Ô∏è Por favor, introduce un motivo antes de registrar la parada.")
            else:

                if opcion_impacto == "Estaci√≥n":
                    zona = ZoneInfo("Europe/Madrid")
                    fila_parada = {
                        "Fecha": datetime.now(zona).strftime("%Y-%m-%d"),
                        "Hora": datetime.now(zona).strftime("%H:%M:%S"),
                        "CEE": st.session_state.usuario_logueado,
                        "L√≠nea": st.session_state.linea,
                        "Estaci√≥n": st.session_state.estacion,
                        "Estado": "Parada producci√≥n",
                        "Operario": "",
                        "Turno": "",
                        "Producto": "",
                        "Unidades producidas": "",
                        "Unidades defectuosas": "",
                        "Observaciones": motivo
                    }
                    st.session_state.df = pd.concat([st.session_state.df, pd.DataFrame([fila_parada])], ignore_index=True)
                    st.session_state.df.to_csv(st.session_state.csv_path, index=False, sep=';', encoding='utf-8-sig')
                    st.session_state[key_estado] = "Parada por incidencia"
                    guardar_estados()  # <-- GUARDAR CAMBIOS
                    st.session_state.produccion_iniciada = False
                    st.success("‚úÖ Parada registrada correctamente.")
                    st.session_state.mostrar_motivo_parada = False  # Ocultar cuadro de texto
                    st.rerun()

                else:
                    zona = ZoneInfo("Europe/Madrid")
                    fila_parada = {
                        "Fecha": datetime.now(zona).strftime("%Y-%m-%d"),
                        "Hora": datetime.now(zona).strftime("%H:%M:%S"),
                        "CEE": st.session_state.usuario_logueado,
                        "L√≠nea": st.session_state.linea,
                        "Estaci√≥n": "",
                        "Estado": "Parada producci√≥n",
                        "Operario": "",
                        "Turno": "",
                        "Producto": "",
                        "Unidades producidas": "",
                        "Unidades defectuosas": "",
                        "Observaciones": motivo
                    }
                    st.session_state.df = pd.concat([st.session_state.df, pd.DataFrame([fila_parada])], ignore_index=True)
                    st.session_state.df.to_csv(st.session_state.csv_path, index=False, sep=';', encoding='utf-8-sig')

                    nombres_estaciones = usuarios[st.session_state.usuario_logueado]["lineas"][st.session_state.linea]["nombres"]

                    for nombre_estacion in nombres_estaciones:
                        key_estado_update = f"estado_linea_{st.session_state.linea}_Estacion_{nombre_estacion}"
                        st.session_state[key_estado_update] = "Parada por incidencia"

                    st.session_state[clave_linea_parada] = True
                    guardar_estados()  # <-- GUARDAR CAMBIOS
                    st.session_state.produccion_iniciada = False
                    st.success("‚úÖ Parada registrada correctamente.")
                    st.session_state.mostrar_motivo_parada = False
                    st.rerun()



    btn_key_finalizar = f"finalizar_{st.session_state.usuario_logueado}_{st.session_state.linea}_{st.session_state.estacion}"
    finalizar_disabled = st.session_state[key_estado] == "No iniciada"

    if st.button("üèÅ Finalizar jornada", disabled=finalizar_disabled, key=btn_key_finalizar):
        zona = ZoneInfo("Europe/Madrid")
        fila_fin = {
            "Fecha": datetime.now(zona).strftime("%Y-%m-%d"),
            "Hora": datetime.now(zona).strftime("%H:%M:%S"),
            "CEE": st.session_state.usuario_logueado,
            "L√≠nea": st.session_state.linea,
            "Estaci√≥n": st.session_state.estacion,
            "Estado": "Fin producci√≥n",
            "Operario": "",
            "Turno": "",
            "Producto": "",
            "Unidades producidas": "",
            "Unidades defectuosas": "",
            "Observaciones": "Fin de la jornada de producci√≥n"
        }
        st.session_state.df = pd.concat([st.session_state.df, pd.DataFrame([fila_fin])], ignore_index=True)
        st.session_state.df.to_csv(st.session_state.csv_path, index=False, sep=';', encoding='utf-8-sig')

        # Establecer "No iniciada" en todas las estaciones al finalizar jornada
        for linea_actual, data_linea in usuarios[usuario]["lineas"].items():
            nombres_estaciones = data_linea.get("nombres", [])
            for nombre_estacion in nombres_estaciones:
                key_estado_update = f"estado_linea_{linea_actual}_Estacion_{nombre_estacion}"
                st.session_state[key_estado_update] = "No iniciada"

        guardar_estados()  # <-- GUARDAR CAMBIOS
        st.session_state.mostrar_motivo_parada = False  # Asegura que no se muestre texto de parada
        st.success("‚úÖ Jornada finalizada correctamente.")
        st.rerun()

    # Si la producci√≥n est√° iniciada, mostrar formulario
    if st.session_state[key_estado] == "En producci√≥n":
        st.markdown("### üßæ Registrar producci√≥n")
        operario = st.text_input("üë§ Operario")
        turno = st.radio("üïí Turno", ["Ma√±ana", "Tarde", "Noche"])

        productos_usuario = usuarios.get(st.session_state.usuario_logueado, {}).get("productos", [])

        if productos_usuario:
            producto = st.selectbox("üì¶ Producto", productos_usuario)
        else:
            st.warning("‚ö†Ô∏è Este usuario no tiene productos configurados.")
            producto = None

        unidades_producidas = st.number_input("üî¢ Unidades producidas", min_value=1, step=1)
        unidades_defectuosas = st.number_input("‚ùå Unidades defectuosas", min_value=0, step=1)
        observaciones = st.text_area("üìù Observaciones")

        if st.button("‚úÖ Registrar producci√≥n"):
            zona = ZoneInfo("Europe/Madrid")
            nueva_fila = {
                "Fecha": datetime.now(zona).strftime("%Y-%m-%d"),
                "Hora": datetime.now(zona).strftime("%H:%M:%S"),
                "CEE": st.session_state.usuario_logueado,  # <-- Cambio aqu√≠
                "L√≠nea": st.session_state.linea,
                "Estaci√≥n": st.session_state.estacion,
                "Estado": st.session_state[key_estado],
                "Operario": operario,
                "Turno": turno,
                "Producto": producto,
                "Unidades producidas": unidades_producidas,
                "Unidades defectuosas": unidades_defectuosas,
                "Observaciones": observaciones
            }
            st.session_state.df = pd.concat([st.session_state.df, pd.DataFrame([nueva_fila])], ignore_index=True)
            st.session_state.df.to_csv(st.session_state.csv_path, index=False, sep=';', encoding='utf-8-sig')
            st.success("‚úÖ Registro guardado correctamente.")
    else:
        st.warning("‚ö†Ô∏è Debes iniciar la producci√≥n antes de poder registrar unidades.")

    # Mostrar √∫ltimos registros
    st.markdown("---")
    st.markdown("### üìã √öltimos registros")
    st.dataframe(st.session_state.df.tail(5), use_container_width=True)



# --- BOTONES DE NAVEGACI√ìN Y EDICI√ìN SEG√öN LA ETAPA ---

if st.session_state.etapa == "inicio_usuario":
    st.markdown("---")
    if st.button("üîô Volver al inicio"):
        st.session_state.etapa = "CEE"
        # Limpia variables que dependen de la selecci√≥n previa
        st.session_state.pop("csv_path", None)
        st.session_state.pop("usuario_logueado", None)  # <-- cambio aqu√≠
        st.session_state.pop("linea", None)
        st.session_state.pop("estacion", None)
        st.session_state.pop("df", None)
        st.session_state.pop("produccion_iniciada", None)
        st.rerun()  # <--- A√±adido

if st.session_state.etapa == "linea":
    st.markdown("---")
    if st.button("üîô Volver al inicio"):
        st.session_state.etapa = "CEE"
        # Limpia variables que dependen de la selecci√≥n previa
        st.session_state.pop("csv_path", None)
        st.session_state.pop("usuario_logueado", None)  # <-- cambio aqu√≠
        st.session_state.pop("linea", None)
        st.session_state.pop("estacion", None)
        st.session_state.pop("df", None)
        st.session_state.pop("produccion_iniciada", None)
        st.rerun()  # <--- A√±adido

elif st.session_state.etapa == "estacion":
    st.markdown("---")
    col1, col2 = st.columns(2)
    with col1:
        if st.button("üîÅ Cambiar l√≠nea"):
            st.session_state.etapa = "linea"
            st.rerun()
    with col2:
        if st.button("üîô Volver al inicio"):
            st.session_state.etapa = "CEE"
            # Limpia variables que dependen de la selecci√≥n previa
            st.session_state.pop("csv_path", None)
            st.session_state.pop("usuario_logueado", None)  # <-- cambio aqu√≠
            st.session_state.pop("linea", None)
            st.session_state.pop("estacion", None)
            st.session_state.pop("df", None)
            st.session_state.pop("produccion_iniciada", None)
            st.rerun()  # <--- A√±adido

elif st.session_state.etapa == "registro":
    # Descargar CSV
    if "csv_path" in st.session_state and os.path.exists(st.session_state.csv_path):
        with open(st.session_state.csv_path, "rb") as f:
            st.download_button(
                "‚¨áÔ∏è Descargar CSV",
                f,
                file_name=f"registro_produccion_{st.session_state.usuario_logueado}.csv",  # <-- cambio aqu√≠
                mime="text/csv"
            )

    # --- Bot√≥n para mostrar/ocultar edici√≥n de registros ---
    if "mostrar_edicion" not in st.session_state:
        st.session_state.mostrar_edicion = False

    if st.button("‚úèÔ∏è Modificar o eliminar un registro"):
        # Verifica si hay registros
        if st.session_state.df.empty:
            st.warning("‚ö†Ô∏è A√∫n no hay registros disponibles para modificar o eliminar.")
            st.session_state.mostrar_edicion = False
        else:
            st.session_state.mostrar_edicion = not st.session_state.mostrar_edicion

    if st.session_state.mostrar_edicion:
        st.markdown("### ‚úèÔ∏è Selecciona un registro reciente")

        ultimos_registros = st.session_state.df.tail(5).reset_index(drop=True)

        def formatear_registro(row):
            # Aqu√≠ puedes dejar el campo 'CEE' para mostrar el usuario/logueado/CEE actual
            return f"{row['Fecha']} - {row['Hora']} - {row['CEE']} - {row['L√≠nea']} - {row['Estaci√≥n']} - {row['Estado']} - {row['Operario']} - {row['Turno']} - {row['Producto']} - {row['Unidades producidas']} - {row['Unidades defectuosas']} - {row['Observaciones']}"

        opciones = [(i, formatear_registro(row)) for i, row in ultimos_registros.iterrows()]
        opciones_dict = {desc: idx for idx, desc in opciones}

        registro_str = st.selectbox("Selecciona un registro", list(opciones_dict.keys()), key="registro_selectbox")
        registro_seleccionado = opciones_dict[registro_str]
        registro = ultimos_registros.loc[registro_seleccionado]

        clave_registro = f"registro_{registro_seleccionado}"

        if registro["Estado"] not in ["Reanudaci√≥n producci√≥n", "Parada producci√≥n"]:
            nuevo_operario = st.text_input("üë§ Operario", value=registro["Operario"], key=f"operario_{clave_registro}")
            turnos_validos = ["Ma√±ana", "Tarde", "Noche"]
            turno_actual = registro.get("Turno", "")
            if turno_actual in turnos_validos:
                nuevo_turno = st.radio("üïí Turno", turnos_validos, index=turnos_validos.index(turno_actual), key=f"turno_{clave_registro}")
            else:
                nuevo_turno = st.radio("üïí Turno", turnos_validos, key=f"turno_{clave_registro}")

            productos_disponibles = ["Producto A", "Producto B", "Producto C"]
            producto_actual = registro.get("Producto", "")

            if producto_actual in productos_disponibles:
                index_producto = productos_disponibles.index(producto_actual)
            else:
                index_producto = 0

            nuevo_producto = st.selectbox("üß± Producto", productos_disponibles, index=index_producto, key=f"producto_{clave_registro}")

            try:
                valor_producidas = int(registro.get("Unidades producidas", 0))
            except (ValueError, TypeError):
                valor_producidas = 0

            nuevas_producidas = st.number_input("üî¢ Unidades producidas", min_value=0, value=valor_producidas, step=1)

            try:
                valor_defectuosas = int(registro.get("Unidades defectuosas", 0))
            except (ValueError, TypeError):
                valor_defectuosas = 0

            nuevas_defectuosas = st.number_input("‚ùå Unidades defectuosas", min_value=0, value=valor_defectuosas, step=1, key=f"defectuosas_{clave_registro}")
            nuevas_observaciones = st.text_area("üìù Observaciones", value=registro["Observaciones"], key=f"observaciones_{clave_registro}")

            if st.button("üíæ Guardar cambios en el registro seleccionado", key=f"guardar_{clave_registro}"):
                index_original = st.session_state.df.tail(5).index[registro_seleccionado]
                st.session_state.df.at[index_original, "Operario"] = nuevo_operario
                st.session_state.df.at[index_original, "Turno"] = nuevo_turno
                st.session_state.df.at[index_original, "Producto"] = nuevo_producto
                st.session_state.df.at[index_original, "Unidades producidas"] = nuevas_producidas
                st.session_state.df.at[index_original, "Unidades defectuosas"] = nuevas_defectuosas
                st.session_state.df.at[index_original, "Observaciones"] = nuevas_observaciones
                st.session_state.df.to_csv(st.session_state.csv_path, index=False, sep=';', encoding='utf-8-sig')
                st.success("‚úÖ Registro modificado correctamente.")
                st.rerun()
        else:
            st.info("üõ† Este registro es de inicio o parada de producci√≥n, solo puede eliminarse.")

        if st.button("üóëÔ∏è Eliminar registro seleccionado", key=f"eliminar_{clave_registro}"):
            index_original = st.session_state.df.tail(5).index[registro_seleccionado]
            eliminar_registro_por_indice(index_original)


    # Eliminar archivo
    if st.button("üóëÔ∏è Eliminar archivo de producci√≥n"):
        if os.path.exists(st.session_state.csv_path):
            os.remove(st.session_state.csv_path)
            st.warning(f"Archivo `{st.session_state.csv_path}` eliminado. Recarga la app para reiniciar.")
        else:
            st.warning("‚ö†Ô∏è No se encontr√≥ el archivo para eliminar.")

    # --- Botones de navegaci√≥n al final ---
    st.markdown("---")
    col1, col2, col3 = st.columns(3)

    with col1:
        if st.button("üîÅ Cambiar estaci√≥n"):
            st.session_state.etapa = "estacion"
            st.rerun()

    with col2:
        if st.button("üîÅ Cambiar l√≠nea"):
            st.session_state.etapa = "linea"
            st.rerun()

    with col3:
        if st.button("üîô Volver al inicio"):
            st.session_state.etapa = "CEE"
            # Limpia variables que dependen de la selecci√≥n previa
            st.session_state.pop("csv_path", None)
            st.session_state.pop("usuario_logueado", None)  # <-- Cambiado de 'cee'
            st.session_state.pop("linea", None)
            st.session_state.pop("estacion", None)
            st.session_state.pop("df", None)
            st.session_state.pop("produccion_iniciada", None)
            st.rerun()  # <--- A√±adido